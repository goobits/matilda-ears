#!/usr/bin/env python3
"""Matilda Ears - Speech-to-Text Engine - Pure speech-to-text engine with multiple operation modes
Generated by Goobits CLI Framework v

This is a consolidated Python CLI file with all utilities embedded.
Generated from: goobits.yaml
"""

import sys
import os
import logging
import traceback
from pathlib import Path
from typing import Any

import click

try:
    import tomllib
except ImportError:  # pragma: no cover
    import toml as tomllib
import toml

# ============================================================================
# EMBEDDED LOGGER
# ============================================================================


class ColoredFormatter(logging.Formatter):
    """Custom formatter with color support."""

    COLORS = {
        "DEBUG": "\033[36m",  # Cyan
        "INFO": "\033[32m",  # Green
        "WARNING": "\033[33m",  # Yellow
        "ERROR": "\033[31m",  # Red
        "CRITICAL": "\033[35m",  # Magenta
    }
    RESET = "\033[0m"

    def format(self, record):
        log_color = self.COLORS.get(record.levelname, self.RESET)
        record.levelname = f"{log_color}{record.levelname}{self.RESET}"
        return super().format(record)


def setup_logging(level=logging.INFO, log_file=None):
    """Configure logging for the CLI."""
    handlers = []

    # Console handler with colors
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(
        ColoredFormatter("%(asctime)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
    )
    handlers.append(console_handler)

    # File handler if specified
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(name)s - %(message)s"))
        handlers.append(file_handler)

    logging.basicConfig(level=level, handlers=handlers)


logger = logging.getLogger(__name__)

# ============================================================================
# EMBEDDED CONFIG MANAGER
# ============================================================================


class ConfigManager:
    """Manage CLI configuration."""

    def __init__(self, config_file: Path | None = None):
        """Initialize configuration manager."""
        self.section = "ears"
        if config_file is None:
            env_path = os.environ.get("MATILDA_CONFIG")
            config_file = Path(env_path) if env_path else Path.home() / ".matilda" / "config.toml"

        self.config_file = Path(config_file)
        self.config_file.parent.mkdir(parents=True, exist_ok=True)
        self.config = self._load_config()

    def _load_config(self) -> dict[str, Any]:
        """Load configuration from file."""
        if self.config_file.exists():
            try:
                with open(self.config_file, "rb") as f:
                    full_config = tomllib.load(f)
                section = full_config.get(self.section)
                if isinstance(section, dict):
                    return section
                return {}
            except Exception as e:
                logger.warning(f"Failed to load config: {e}")
                return {}
        return {}

    def save_config(self) -> bool:
        """Save configuration to file."""
        try:
            if self.config_file.exists():
                with open(self.config_file, "rb") as f:
                    full_config = tomllib.load(f)
            else:
                full_config = {}

            full_config[self.section] = self.config
            with open(self.config_file, "w", encoding="utf-8") as f:
                f.write(toml.dumps(full_config))
            return True
        except Exception as e:
            logger.error(f"Failed to save config: {e}")
            return False

    def get(self, key: str, default: Any = None) -> Any:
        """Get configuration value."""
        keys = key.split(".")
        value = self.config
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
                if value is None:
                    return default
            else:
                return default
        return value

    def set(self, key: str, value: Any):
        """Set configuration value."""
        keys = key.split(".")
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value


# ============================================================================
# EMBEDDED ERROR HANDLER
# ============================================================================


class CLIError(Exception):
    """Base exception for CLI errors."""

    exit_code = 1


class UsageError(CLIError):
    """Exception for usage errors."""

    exit_code = 2


class ConfigError(CLIError):
    """Exception for configuration errors."""

    exit_code = 3


def handle_error(error: Exception, verbose: bool = False):
    """Handle CLI errors consistently."""
    if isinstance(error, CLIError):
        logger.error(str(error))
        if verbose:
            logger.debug(traceback.format_exc())
        sys.exit(error.exit_code)
    else:
        logger.error(f"Unexpected error: {error}")
        if verbose:
            logger.debug(traceback.format_exc())
        else:
            logger.info("Run with --verbose for more details")
        sys.exit(1)


# ============================================================================
# CLI CONTEXT
# ============================================================================


class CLIContext:
    """Shared context for CLI commands."""

    def __init__(self, config: ConfigManager, verbose: bool = False, debug: bool = False):
        self.config = config
        self.verbose = verbose
        self.debug = debug

        # Setup logging based on verbosity
        if debug:
            setup_logging(logging.DEBUG)
        elif verbose:
            setup_logging(logging.INFO)
        else:
            setup_logging(logging.WARNING)


# ============================================================================
# HOOK SYSTEM
# ============================================================================
def load_hooks():
    """Load user-defined hooks."""
    try:
        import matilda_ears.app_hooks as hooks_module

        return hooks_module
    except ImportError:
        logger.warning("No hooks module found. Please create one with your command implementations.")
        logger.warning("Example:")
        logger.warning("  def on_build(ctx, **kwargs):")
        logger.warning("      print('Build command implementation')")
        return None


hooks = load_hooks()

# ============================================================================
# CLI COMMANDS
# ============================================================================


@click.group()
@click.option("--verbose", "-v", is_flag=True, help="Enable verbose output")
@click.option("--debug", is_flag=True, help="Enable debug output")
@click.option("--config", type=click.Path(), help="Path to config file (default: ~/.matilda/config.toml)")
@click.pass_context
def cli(ctx, verbose, debug, config):
    """Transform speech into text with AI-powered transcription using Whisper models."""
    config_path = Path(config) if config else None
    config_manager = ConfigManager(config_path)
    ctx.obj = CLIContext(config_manager, verbose, debug)


@cli.command("status")
@click.option("--json", is_flag=True, default=None, help="Output JSON format")
@click.pass_obj
def status(ctx, json):
    """Show system status and capabilities"""
    try:
        if hooks and hasattr(hooks, "on_status"):
            kwargs = {"json": json}
            hooks.on_status(ctx=ctx, **kwargs)
        else:
            logger.error("Hook 'on_status' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)


@cli.command("models")
@click.option("--json", is_flag=True, default=None, help="Output JSON format")
@click.pass_obj
def models(ctx, json):
    """List available Whisper models"""
    try:
        if hooks and hasattr(hooks, "on_models"):
            kwargs = {"json": json}
            hooks.on_models(ctx=ctx, **kwargs)
        else:
            logger.error("Hook 'on_models' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)


@cli.command("download")
@click.option("--model", default="base", help="Model size to download (tiny, base, small, medium, large-v3-turbo)")
@click.option("--progress", is_flag=True, default=None, help="Show JSON progress events (for programmatic use)")
@click.pass_obj
def download(ctx, model, progress):
    """Download Whisper model for offline use"""
    try:
        if hooks and hasattr(hooks, "on_download"):
            kwargs = {"model": model, "progress": progress}
            hooks.on_download(ctx=ctx, **kwargs)
        else:
            logger.error("Hook 'on_download' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)


@cli.command("train-wake-word")
@click.option("--phrase", default=None, help="The wake word phrase to train (e.g., 'hey matilda')")
@click.option("--output", default=None, help="Output path for ONNX file (default: models/{phrase}.onnx)")
@click.option("--samples", default="3000", help="Number of training samples to generate")
@click.option("--epochs", default="10", help="Number of training epochs")
@click.pass_obj
def train_wake_word(ctx, phrase, output, samples, epochs):
    """Train a custom wake word model using Modal.com cloud GPU"""
    try:
        if hooks and hasattr(hooks, "on_train_wake_word"):
            kwargs = {"phrase": phrase, "output": output, "samples": samples, "epochs": epochs}
            hooks.on_train_wake_word(ctx=ctx, **kwargs)
        else:
            logger.error("Hook 'on_train_wake_word' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)


# ============================================================================
# INTERACTIVE MODE (if enabled)
# ============================================================================
# ============================================================================
# MAIN ENTRY POINT
# ============================================================================


def main():
    """Main entry point for the CLI."""
    try:
        cli()
    except Exception as e:
        handle_error(e, "--verbose" in sys.argv or "--debug" in sys.argv)


# Alias for compatibility with different entry point names
cli_entry = main

if __name__ == "__main__":
    main()
